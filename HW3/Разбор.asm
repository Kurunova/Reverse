401383 MOV AL, [ESI]  ; загружаем байт из строки
TEST AL, AL    ; проверяем, не достигли ли конца строки

; TEST влияет на флаги
; Флаг	Значение
; ZF (Zero Flag)	Становится 1, если AL == 0
; SF (Sign Flag)	Отражает старший бит результата (для знаковых)
; PF (Parity Flag)	1, если в результате чётное количество единиц

JE crackme-31158-f16266.40139C  ; Jump if Equal → переход, если флаг ZF = 1

CMP AL, 41  ; Перед этим в AL лежала буква 'E', а ASCII 'E' = 0x45. 
            ; Число 41 в шестнадцатеричном виде, то есть 'A' в ASCII
            ; CMP 0x45, 0x41 → 0x04 (разность положительная, не равны),
            ; ZF = 0, CF = 0
JB crackme-31158-f16266.4013AC ; Jump if Below.	Переход, если меньше, но беззнаковое сравнение
            ; Переход происходит, если CF = 1, то есть если AL < 41h (беззнаково) → перейти

CMP AL, 5Ah     ; сравнение с 'Z'
; CMP влияет на флаги
; Флаг	Значение	Почему
; CF	1	Так как AL < 0x5A (в беззнаковом смысле) → будет перенос (Carry)
; ZF	0	'E' ≠ 'Z'
; SF	зависит,	результат отрицательный → SF = 1
; OF	0	Нет переполнения
; PF	зависит,	зависит от результата
JAE crackme-31158-f16266.401394 ; Jump if Above or Equal (беззнаково), если CF = 0,	если AL >= 'Z' (беззнаково) → перейти

INC ESI ; следующий символ

JMP crackme-31158-f16266.401383 ; 

40139C CALL crackme-31158-f16266.4013C2 ; процедура, будет идти до ret
; Кладёт текущий EIP в стек (чтобы знать, куда возвращаться)
; Переходит на указанный адрес 004013C2

4013C2 XOR edi, edi ; Обнуляет регистр EDI (004013C2)
XOR ebx, ebx ; Обнуляет регистр EBX
MOV bl, byte ptrds:[esi]
TEST bl,bl 
JE crackme-31158-f16266.4013D1 ; 
ADD edi,ebx
INC ESI 
4013D1 ret ; возврат в 40139C

; -----------------
; если у нас буква была меньше A, то нас отправляло по адресу 4013AC, где далее 
4013AC pop esi
push 30
push crackme-31158-f16266.402160
push crackme-31158-f16266.402169
push dword ptrss:[ebp+8]
call <JMP.&MessageBoxA>
ret
; тут как я понимаю завершение работы и выдача того что алгоритм не удался

; -----------------
; если буква больше z, то вызываем процедуру
401394 CALL crackme-31158-f16266.4013D2 ;
sub al,20 ; Отнимаем 0x20 от AL, то есть если символ был 'e' = 0x65, то: 0x65 - 0x20 = 0x45 → 'E'
mov byte ptrds:[esi],al ; Записываем обновлённое значение обратно в строку по адресу esi.
ret
; ? а если 2 раза на 0x20 уехали вправо, больше z ?